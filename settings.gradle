plugins {
    id 'org.gradle.toolchains.foojay-resolver-convention' version '0.9.0'
}

rootProject.name = 'limetrans'

gradle.rootProject {
    group = 'hbz.' + name

    def baseUrl = project.hasProperty('git.baseUrl') ?
        project.getProperty('git.baseUrl') : null

    ext {
        versions = [
            checkstyle:     '10.25.0',
            commons_cli:    '1.3.1',
            commons_io:     '2.14.0',
            elasticsearch:  '2',
            elasticsearch2: '2.2.1',
            elasticsearch8: '8.19.10',
            elasticsearch9: '9.2.4',
            htsjdk:         '4.3.0',
            jackson:        '2.13.4.2',
            jdk:            '17',
            junit:          '4.13.1',
            lmdb:           '0.8.3',
            log4j:          '2.17.1',
            lucene5:        '5.4.1',
            metafacture:    '7.0.0',
            testcontainers: '2.0.2'
        ]

        // https://github.com/lmdbjava/lmdbjava/issues/42
        lmdbJvmArgs = [
            '--add-opens=java.base/java.nio=ALL-UNNAMED',
            '--add-opens=java.base/sun.nio.ch=ALL-UNNAMED',

            // Required for ElasticsearchIndexerTest: ShardNotFoundException[no such shard]
            '--add-opens=java.base/jdk.internal.ref=ALL-UNNAMED'
        ]

        testMatrix = [
            metafacture: [
                'master'
            ]
        ]

        gitModules = [
            metafacture: [
                base: 'https://github.com/metafacture',
                repo: 'metafacture-core',
                modules: [
                    'org.metafacture:metafacture-biblio',
                    'org.metafacture:metafacture-commons',
                    'org.metafacture:metafacture-flowcontrol',
                    'org.metafacture:metafacture-formeta',
                    'org.metafacture:metafacture-framework',
                    'org.metafacture:metafacture-io',
                    'org.metafacture:metafacture-javaintegration',
                    'org.metafacture:metafacture-json',
                    'org.metafacture:metafacture-mangling',
                    'org.metafacture:metafacture-plumbing',
                    'org.metafacture:metafacture-runner',
                    'org.metafacture:metafacture-statistics',
                    'org.metafacture:metafacture-strings',
                    'org.metafacture:metafacture-xml',
                    'org.metafacture:metafix',
                    'org.metafacture:metamorph'
                ],
                dependency: {
                    it.exclude(group: 'org.slf4j', module: 'slf4j-reload4j')
                    it.exclude(group: 'org.slf4j', module: 'slf4j-simple')
                }
            ]
        ]

        versionsProperty = [
            prefix: 'versions',
            separator: '.'
        ]

        printVersions = {
            versions.sort().each { key, value -> println "- ${key}=${value}" }
        }

        def systemPropertyPrefix = group + '.'
        def elasticsearchVersionProperty = systemPropertyPrefix + 'elasticsearchVersion'

        elasticsearchVersion = System.getProperty(elasticsearchVersionProperty) ?: versions.elasticsearch

        passSystemProperties = {
            def versionsPrefix = systemPropertyPrefix + versionsProperty.prefix + versionsProperty.separator

            def versionsPattern = ~/elasticsearch\d+/
            def propertiesPattern = ~/(?:\Q${systemPropertyPrefix}\E|org\.metafacture\.).*/

            versions.each { k, v ->
                if (k.matches(versionsPattern)) it[versionsPrefix + k] = v
            }

            it[systemPropertyPrefix + 'projectDir'] = rootProject.projectDir
            it[elasticsearchVersionProperty] = elasticsearchVersion

            System.properties.each { k, v ->
                if (k.matches(propertiesPattern)) it[k] = v
            }
        }
    }

    def separator = "\\Q${versionsProperty.separator}\\E"
    rootProject.properties.each { key, value ->
        if (value instanceof String && !value.isEmpty()) {
            def parts = key.split(separator)
            if (parts.size() == 2 && parts[0] == versionsProperty.prefix) {
                versions[parts[1]] = value
            }
        }
    }

    sourceControl {
        gitModules.each { key, args ->
            def version = versions[key]
            if (version.matches(~/\d+(?:\..*)?|.*-rc\d+|.*-SNAPSHOT/)) {
                args.version = { prefer version }
            }
            else {
                args.version = { branch = version }

                gitRepository("${baseUrl ?: args.base}/${args.repo}") {
                    args.modules.each { producesModule(it) }
                }
            }
        }
    }
}

include ':core'
include ':es2'
include ':es8'
include ':es9'
include ':main'
